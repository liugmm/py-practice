## 简单工厂模式 - Simple Factory Pattern

核心思想：通过一个工厂类，根据传入的参数决定创建哪种具体产品类的实例

优点：
- 集中管理对象的创建逻辑，降低耦合。
- 客户端无需知道具体类的名称，只需通过参数调用。

缺点：
- 新增产品需修改工厂类，违反开闭原则。

## 工厂方法模式 - Factory Method Pattern

核心思想：定义一个创建对象的接口，由子类决定实例化哪个类。每个具体工厂类负责创建一种具体产品。

优点
1. 解耦：工厂方法模式将对象的创建与使用分离，降低了系统的耦合度。

2. 扩展性：增加新的产品类时，只需添加相应的具体工厂类，无需修改原有代码，符合开闭原则。

3. 单一职责原则：工厂类负责对象的创建，产品类负责对象的行为，职责划分明确。

4. 客户端代码无需知道具体产品类：客户端只需要知道抽象产品接口和抽象工厂接口，无需关心具体的实现。

缺点
1. 增加了代码量：每增加一个产品就需要增加一个具体产品类和一个对应的具体工厂类，可能会导致类的数量增加。

2. 增加了系统的复杂度：引入了抽象层，可能会使得系统更加复杂，理解起来需要更多的时间。

3. 增加了系统抽象性和理解难度：对于不熟悉该模式的开发者来说，理解和实现工厂方法模式可能需要一定的学习成本。

应用场景
1. 当一个类不知道它所需要的对象的类时：当一个类希望由其子类来指定它所创建的对象时。

2. 当一个类希望由其子类来创建对象时：当类将创建对象的职责委托给多个帮助子类中的一个，并且希望将哪个子类是代理者的信息局部化时。

3. 当类将创建对象的职责委托给多个帮助子类中的一个，并且希望将哪个子类是代理者的信息局部化时：这样可以让每个子类创建自己的对象。

4. 当需要灵活应对需求变化时：当系统需要添加新产品时，可以增加新的具体工厂和具体产品，而不需要修改原有的代码。


## 抽象工厂模式 - Abstract Factory Pattern

核心思想：抽象工厂模式的核心思想是提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。这样可以在不改变客户端代码的情况下引入新的产品家族。

优点:

1.隔离了具体类的生成，使得客户端不需要知道什么被创建。
2.易于交换产品系列，只需在客户端更换具体工厂即可。
3.有利于产品一致性，确保同一工厂创建的产品是相互兼容的。

缺点:

1.增加了系统的抽象性和理解难度。
2.扩展新的产品等级结构（即新增产品族）比较困难，需要修改抽象工厂和所有具体工厂。

应用场景
1.当系统需要独立于其产品的创建、组合和表示时。
2.当系统需要配置多个产品家族中的一个时。
3.当强调一系列相关产品对象的设计以便进行联合使用时。
4.当需要提供一个产品类库，只想显示它们的接口而不是实现时。


## 建造者模式 - Builder Pattern

原型模式 - Prototype Pattern

单例模式 - Singleton Pattern

适配器模式 - Adapter Pattern

桥梁模式/桥接模式 - Bridge Pattern

组合模式 - Composite Pattern

装饰模式 - Decorator Pattern

门面模式/外观模式 - Facade Pattern

享元模式 - Flyweight Pattern

代理模式 - Proxy Pattern

责任链模式 - Chain of Responsibility Pattern

命令模式 - Command Pattern

解释器模式 - Interpreter Pattern

迭代器模式 - Iterator Pattern

中介者模式 - Mediator Pattern

备忘录模式 - Memento Pattern

观察者模式 - Observer Pattern

状态模式 - State Pattern

策略模式 - Strategy Pattern

模板方法模式 - Template Method Pattern

访问者模式 - Visitor Pattern